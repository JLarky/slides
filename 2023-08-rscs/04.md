# How

I'm going to start with something extremely simple, but because it's usually hidden from you by the framework it could still be extremely surprising.

I'm guessing everyone has seen a very similar code before. We are using the CDN version of React and obviously, you can't just write JSX inside a script tag. But this should look familiar:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
      import React from "https://esm.sh/react";
      import { createRoot } from "https://esm.sh/react-dom/client";

      const reactNode = <div>Hello</div>;
      // or React.createElement
      // const reactNode = jsx("div", { children: "Hello" });

      createRoot(document.getElementById("root")).render(reactNode);
    </script>
  </body>
</html>
```

Let's make it a real app, This is almost identical to what is going on in CRA (and you can actually run it from demos/simple/03_app.html):

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Title</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
      import React from "https://esm.sh/react";
      import { createRoot } from "https://esm.sh/react-dom/client";
      import { jsx } from "https://esm.sh/react/jsx-runtime";

      const App = () => {
        const [name, setName] = React.useState("Hello");
        return jsx("div", { children: name });
      };

      createRoot(document.getElementById("root")).render(jsx(App, {}));
    </script>
  </body>
</html>
```

Let's go one step further and use "hydrateRoot".

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Title</title>
  </head>
  <body>
    <div id="root"><div>Hello</div></div>
    <script type="module">
      import React from "https://esm.sh/react";
      import { hydrateRoot } from "https://esm.sh/react-dom/client";
      import { jsx } from "https://esm.sh/react/jsx-runtime";

      const App = () => {
        const [name, setName] = React.useState("Hello");
        React.useEffect(() => {
          setTimeout(() => {
            setName("Hello World");
          }, 1000);
        }, []);
        return jsx("div", { children: name });
      };

      hydrateRoot(document.getElementById("root"), jsx(App, {}));
    </script>
  </body>
</html>
```

How hard would it be to hydrate the whole document instead of just the #root div? Well, just re-create everything as a React tree:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Title</title>
  </head>
  <body>
    <div id="root"><div>Hello</div></div>
    <script type="module">
      import React from "https://esm.sh/react?dev";
      import { hydrateRoot } from "https://esm.sh/react-dom/client?dev";
      import { jsx, jsxs } from "https://esm.sh/react/jsx-runtime?dev";

      const App = () => {
        const [name, setName] = React.useState("Hello");
        React.useEffect(() => {
          setTimeout(() => {
            setName("Hello World");
          }, 1000);
        }, []);
        return jsx("div", { children: name });
      };

      hydrateRoot(
        document,
        jsxs("html", {
          lang: "en",
          children: [
            jsx("head", {
              children: jsx("title", {
                children: "Title",
              }),
            }),
            jsxs("body", {
              children: [
                jsx("div", {
                  id: "root",
                  children: jsx(App, {}),
                }),
                jsx("script", {
                  suppressHydrationWarning: true,
                  children: "",
                }),
              ],
            }),
          ],
        })
      );
    </script>
  </body>
</html>
```

I want to stress that I'm using `jsx` and `jsxs` functions here just to make the syntax a bit nicer. Keep in mind that those functions are extremely simple and what they do is just create a plain JS object like this:

```js
const jsx = (type, props) => ({
  "$$typeof": Symbol.for("react.element"),
  type,
  props,
});
```

So `reactNode` is just an object, and `type` is sometimes a function and sometimes it's just a string. So the question is, can I just call a `JSON.stringify` on the whole object and send it over the wire?

The intuition here is that it's going to be easier to do that using this format, compared to the alternative where your whole app is defined inside the `App` function.

With that in mind let's play a bit more with what we have created so far :)

DEMO TIME with 2023-08-rscs/demos/simple/08_re-render.html

## Links:

- [JSX transform](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md)
- [debug JSX transform](https://www.typescriptlang.org/play?target=99&jsx=4&ssl=1&ssc=1&pln=3&pc=1#code/PTAEGUFNNAXALGA6AUuOBDARqA9gOzkVACcBLAc3llAAcN8YAzXEomXAV1lu6QCh+wAFTD+oYaADqiQhlBoAGqEgAbSAFtI+GvAwBnUBs6rYZWutABjeGVUATEtoA0C8Mv0BPHRgAeoMkMrXA1aO0h7OFxQACt9X30ACgBKcUkASSZ2N2UbO0dtUAwnUH1YDDMrVwQOEntINgB3AkBMAhobBgpIV31ozy5Qe1bdDAA3GFho-VpIKzImTyLQAGtITwEJYH5IX1pWGiZOfCszAghyypTQAG9xUkhYThJCRLvQUAAeag1VAD4396fRAYSLAf6AwEfLC4eyLMEAj7Ab5-O6pAC+ghEYgk0lkSyUKnUWh0oD0hgADHg2ABGay2BxOfCuAleHz+QLWEJhdSRSaxeIpNKgdKEBAcqwGbrZPIOAKGeT6Mj4CiWAk7WhOfSKs4ICqkjC0Gb4Qx8+C4WUMIokEgYdZCgBKkAwJ0GuEg+nwbRW+FwjVAjT0NBqVpti2CWkMTBIIR60SdNjp+VKZpMkWms3mi3kqztm22u32oEOx1OhAAIt4MBoyFYrrd3k5Hs9QK8IV9YD9wRCbgBtAFt4Gg37OfuQ6Gw0Dw7ugAC6GLbSI7KPe6P4QA)
