## RSCs and unnecessary complexity

Okay, let me sell you a controversial idea: React Server Components are extremely simple.

Dan Abramov did a talk where he show what would have happened if React was a server-templating library before it became a browser view library.

[React from Another Dimension](https://www.youtube.com/watch?v=zMf_xeGPn6s)

<!-- Side note: we actually know what would have happened. It would have looked more like [MarkoJS](https://markojs.com/) or [Astro](https://astro.build/) than RSCs. So I propose you a simpler way of looking at it. -->

## Radical proposal

Let's see what would have happened if we had a view library for a browser and then decided to add server functionality to it.

### Step 1. Let's put the whole website into one big component.

Yes, React started as a view library to make the like button interactive in a server-rendered template.

But if we want to handle routing, then your apps have to be "fully built with React" (an official term from new React docs).

We want React to handle everything, including `<title>` tag has to be inside `<App />`.

<!-- Side note: again, that goes pretty much the opposite of how islands work. In islands you want the view library to take over just a small island, keeping everything else static -->

### Step 2.1

Compared to server-templating frameworks that have to solve the issue of "How do I keep some of the elements on the page when I navigate?". In React we have the opposite problem: "How do I get new elements when I navigate?".

It could be fun if every component could have a server loader (if you like Remix) or change props (if you like Next) when the route changes.

### Step 2.2

Heck, it could be even cooler if on navigation the code for the component could change as well. Maybe if I go into an extended view of the blog post, I could get a new version of the component that has a comment section.

Yes, we have `React.lazy`, but imagine if it was smarter and could bundle everything needed taking into account current route data.

### Step 3

None of these concerns sound too much like traditional frameworks (like Rails or Django) so far. To compete with them, we would have to render the page into actual HTML! The problem is that we would need to render (or hydrate) the page later on the client anyway. This sounds a little silly, but what if we could just run the same client code on the server and we could call that "SSR" (while technically the process should be called "server pre-rendering of client app")?

### Step 4

In traditional server frameworks, I can read and write cookies, and other headers, redirect users, etc. This part doesn't seem to be solved much, thus I find "React from another dimension" idea slightly less realistic ;)

## Why do I call this simple?

If you look closely, you may notice that none of these require any changes to React at first glance. A lot of this could be done outside of React with a help of a "framework".

Let's go and look at how hard it would have been to implement it.
