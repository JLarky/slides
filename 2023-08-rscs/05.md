# First, let's talk about JSX

I used React for the first few years without using JSX, but I think a lot of people don't think about how JSX works. Let's do this fun detour and maybe this Demo will help you understand how full-stack frameworks work.

To make everything more clear we are not going to use any bundlers, just features available in modern browsers.

Let's start very simple. I want to put my whole React app in one `index.html` file. Let's just get `react` and `react-dom` from a CDN and render our app into `#root` div.

<!-- /Users/jlarky/Public/github/JLarky/slides/2023-08-rscs/demos/simple/01_start.html -->

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
      import React from "https://esm.sh/react";
      import { createRoot } from "https://esm.sh/react-dom/client";

      // const reactNode = <div>Hello</div>;
      // const reactNode = jsx("div", { children: "Hello" });
      const reactNode = React.createElement("div", {}, "Hello");

      createRoot(document.getElementById("root")).render(reactNode);
    </script>
  </body>
</html>
```

Let's make it resemble CRA a bit more. Our app root is going to be a `<App />` component. And we can even add some state to it.

<!-- /Users/jlarky/Public/github/JLarky/slides/2023-08-rscs/demos/simple/03_app.html -->

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Title</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
      import React from "https://esm.sh/react";
      import { createRoot } from "https://esm.sh/react-dom/client";
      import { jsx } from "https://esm.sh/react/jsx-runtime";

      const App = () => {
        const [name, setName] = React.useState("Hello");
        return jsx("div", { children: name });
      };

      createRoot(document.getElementById("root")).render(jsx(App, {}));
    </script>
  </body>
</html>
```

If you ever wondered how full-stack frameworks do hydration, it's going to be extremely similar, just use `hydrateRoot` instead of `createRoot`.

<!-- /Users/jlarky/Public/github/JLarky/slides/2023-08-rscs/demos/simple/04_hydrate.html -->

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Title</title>
  </head>
  <body>
    <div id="root"><div>Hello</div></div>
    <script type="module">
      import React from "https://esm.sh/react";
      import { hydrateRoot } from "https://esm.sh/react-dom/client";
      import { jsx } from "https://esm.sh/react/jsx-runtime";

      const App = () => {
        const [name, setName] = React.useState("Hello");
        React.useEffect(() => {
          setTimeout(() => {
            setName("Hello World");
          }, 1000);
        }, []);
        return jsx("div", { children: name });
      };

      hydrateRoot(document.getElementById("root"), jsx(App, {}));
    </script>
  </body>
</html>
```

Because we are trying to write a "fully built with React" framework, we want to use React to change stuff like `<title />` and `<meta />` tags. Again, pretty easy, just put more stuff in React root.

<!-- /Users/jlarky/Public/github/JLarky/slides/2023-08-rscs/demos/simple/06_react18.html -->

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Title</title>
  </head>
  <body>
    <div id="root"><div>Hello</div></div>
    <script type="module">
      import React from "https://esm.sh/react?dev";
      import { hydrateRoot } from "https://esm.sh/react-dom/client?dev";
      import { jsx, jsxs } from "https://esm.sh/react/jsx-runtime?dev";

      const App = () => {
        const [name, setName] = React.useState("Hello");
        React.useEffect(() => {
          setTimeout(() => {
            setName("Hello World");
          }, 1000);
        }, []);
        return jsx("div", { children: name });
      };

      hydrateRoot(
        document,
        jsxs("html", {
          lang: "en",
          children: [
            jsx("head", {
              children: jsx("title", {
                children: "Title",
              }),
            }),
            jsxs("body", {
              children: [
                jsx("div", {
                  id: "root",
                  children: jsx(App, {}),
                }),
                jsx("script", {
                  suppressHydrationWarning: true,
                  children: "",
                }),
              ],
            }),
          ],
        })
      );
    </script>
  </body>
</html>
```

At this point let's talk more about `jsx` function (ask me about `jsxs` later). This is literally the code that your bundler is going to generate, but you rarely hear anyone from React team talk about it in the context of RSCs. The reason is pretty simple, it's not the best format to send over the wire. So if you read [RSC From Scratch by Dan Abramov](https://github.com/reactwg/server-components/discussions/5) he talks about this form instead:

```js
// <div> => jsx("div", {}) => { $$typeof: Symbol.for("react.element"), type: "div", props: {} }
const jsx = (type, props) => ({
  "$$typeof": Symbol.for("react.element"),
  type,
  props,
});
```

This is how it works, function `jsx` returns just a plain object marked with `$$typeof` field. `type` is a function for components and a string for elements.

Let's do something naive. We are going to take our whole React root starting with `jsx("html", ...)` and serialize it to string, then dehydrate it into a form that we can still use in `hydrateRoot` function.

<!-- /Users/jlarky/Public/github/JLarky/slides/2023-08-rscs/demos/simple/08_serialize.html -->

```js
const reactNode = jsxs("html", {
  lang: "en",
  children: [...],
});

function packUnpack(reactNode) {
  const jsxString = JSON.stringify(reactNode, function replacer(key, value) {}, 2);
  const dehydrated = JSON.parse(jsxString, function reviver(key, value) {});
  return dehydrated;
}

hydrateRoot(document, packUnpack(reactNode));
```

If we can make this work, it opens fun opportunities, like maybe we don't have to have `reactNode` in the browser anymore, it's enough to just send `jsxString` along with the page.

## How is that different from traditional SSG/SSR?

You can express previous approaches in this form:

```js
const reactNode = jsxs("html", {
  lang: "en",
  children: [
    // ...,
    jsx(App, getServerSideProps()),
    // ...
  ],
});
```

Then props are just going to become a static JSON that you send inside `jsxString`.

## A few more notes

The more stuff you have that lives in `reactNode` as static JSON the better. That will make your `App` function smaller and you would have to do less work in SSR/hydration because you have to run `App` twice` (once on the server and once on the client).

This also means that you can have as many client components like `App` as you like (each with its own loader/getServerSideProps), compared to traditional SSR frameworks that had just one.

## TODO

So the question is, can I just call a `JSON.stringify` on the whole object and send it over the wire?

The intuition here is that it's going to be easier to do that using this format, compared to the alternative where your whole app is defined inside the `App` function.

With that in mind let's play a bit more with what we have created so far :)

DEMO TIME with 2023-08-rscs/demos/simple/08_re-render.html

## Links:

- [JSX transform](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md)
- [debug JSX transform](https://www.typescriptlang.org/play?target=99&jsx=4&ssl=1&ssc=1&pln=3&pc=1#code/PTAEGUFNNAXALGA6AUuOBDARqA9gOzkVACcBLAc3llAAcN8YAzXEomXAV1lu6QCh+wAFTD+oYaADqiQhlBoAGqEgAbSAFtI+GvAwBnUBs6rYZWutABjeGVUATEtoA0C8Mv0BPHRgAeoMkMrXA1aO0h7OFxQACt9X30ACgBKcUkASSZ2N2UbO0dtUAwnUH1YDDMrVwQOEntINgB3AkBMAhobBgpIV31ozy5Qe1bdDAA3GFho-VpIKzImTyLQAGtITwEJYH5IX1pWGiZOfCszAghyypTQAG9xUkhYThJCRLvQUAAeag1VAD4396fRAYSLAf6AwEfLC4eyLMEAj7Ab5-O6pAC+ghEYgk0lkSyUKnUWh0oD0hgADHg2ABGay2BxOfCuAleHz+QLWEJhdSRSaxeIpNKgdKEBAcqwGbrZPIOAKGeT6Mj4CiWAk7WhOfSKs4ICqkjC0Gb4Qx8+C4WUMIokEgYdZCgBKkAwJ0GuEg+nwbRW+FwjVAjT0NBqVpti2CWkMTBIIR60SdNjp+VKZpMkWms3mi3kqztm22u32oEOx1OhAAIt4MBoyFYrrd3k5Hs9QK8IV9YD9wRCbgBtAFt4Gg37OfuQ6Gw0Dw7ugAC6GLbSI7KPe6P4QA)
